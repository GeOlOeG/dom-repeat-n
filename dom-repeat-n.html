<link rel="import" href="../polymer/polymer.html">

<!--
A template element that repeat `n` times its content.

Example:

    <template is="dom-repeat-n" count="3">
      <div>I am div {{index}}</div>
    </template>

@demo demo/index.html
@hero hero.svg
-->
<script>
  Polymer({
    is: 'dom-repeat-n',
    extends: 'template',
    // The following specifies that the element stamp directly no content,
    // i.e. does not have a <template> section declared
    _template: null,

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */

    properties: {
      /**
       * `count` specifies the number of times to repeat the template content.
       */
      count: {
        type: Number,
        value: 0, 
        observer: '_countChanged'
      },

      /**
       * `start` specifies the value of the first index and default to 0.
       */
      start: {
        type: Number,
        value: 0
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the inst.  If `order` is provided, the index will reflect the
       * sorted order (rather than the original array order).
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * A string indicating the ordering 'ascending' or 'descending'.
       */
      order: {
        type: String,
        value: 'ascending'
      }

    },

    behaviors: [
      Polymer.Templatizer
    ],

    observers: [
      '_indexesChanged(start, order)'
    ],

    // Element Lifecycle

    created: function() {
      this._instances = [];
      this._pool = [];
      this._order = 1;
    },

    ready: function() {
      // Template instance props that should be excluded from forwarding
      this._instanceProps = {};
      this._instanceProps[this.indexAs] = true;
      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.ctor) {
        this.templatize(this);
      }
      console.log("ready!");
    },

    attached: function() {
      var parent = Polymer.dom(Polymer.dom(this).parentNode);
      for (var i=0; i<this._instances.length; i++) {
        this._attachInstance(i, parent);
      }
    },

    detached: function() {
      for (var i=0; i<this._instances.length; i++) {
        this._detachInstance(i);
      }
    },

    // Element Behavior

    _countChanged: function(newCount, oldCount) {
      if (newCount < 0) {
        console.error("dom-repeat-n: count cannot be negative");
        return;
      }
      this.debounce('update-count', function() {
        console.log("_countChanged: " + newCount);
        console.log("_countChanged: " + oldCount);
        oldCount = oldCount || 0;
        var i;
        // Generate possible missing instances if count increased
        for (i=oldCount; i<newCount; i++) {
          var inst = this._instances[i];
          if (!inst) {
            inst = this._insertInstance(i);
          }
        }
        // Remove any extra instances from previous state
        var limit = this._instances.length;
        for (i=newCount; i<limit; i++) {
          console.log('_countChanged: removing ' + i);
          this._detachAndRemoveInstance(i);
        }        
      });
    },

    _indexesChanged: function(start, order) {
      this.debounce('update-index', function() {
        console.log("_indexesChanged: " + start);
        console.log("_indexesChanged: " + order);
        switch(order) {
          case 'ascending':
            console.log('Ascending');
            this._order = 1;
            break;
          case 'descending':
            console.log('Descending');
            this._order = -1;
            break;
          default:
            console.warn('Invalid order value (' + order + ') for dom-repeat-n.');
            this._order = 1;
        }
        for (var i=0; i<this.count; i++) {
          var inst = this._instances[i];
          if (this._order > 0) {
            inst.__setProperty(this.indexAs, i+this.start, true);
          } else {
            inst.__setProperty(this.indexAs, this.count-i-1+this.start, true);
          }
        }
      });
    },

    _attachInstance: function(idx, parent) {
      var inst = this._instances[idx];
      parent.insertBefore(inst.root, this);
    },

    _detachInstance: function(idx) {
      var inst = this._instances[idx];
      for (var i=0; i<inst._children.length; i++) {
        var el = inst._children[i];
        Polymer.dom(inst.root).appendChild(el);
      }
      return inst;        
    },

    _detachAndRemoveInstance: function(idx) {
      var inst = this._detachInstance(idx);
      if (inst) {
        this._pool.push(inst);
      }
      this._instances.splice(idx, 1);
    },

    _stampInstance: function(idx) {
      console.log("_stampInstance: " + idx);
      var model = {};
      model[this.indexAs] = idx;
      return this.stamp(model);
    },

    _insertInstance: function(idx) {
      console.log("_insertInstance: " + idx);
      var inst = this._pool.pop();
      if (!inst) {
        inst = this._stampInstance(idx);
        if (this._order > 0) {
          inst.__setProperty(this.indexAs, idx, true);
        } else {
          inst.__setProperty(this.indexAs, this.count-idx-1, true);
        }
        this._instances.push(inst);
      }
      var beforeRow = this._instances[idx + 1];
      var beforeNode = (beforeRow && !beforeRow.isPlaceholder) ? beforeRow._children[0] : this;
      var parentNode = Polymer.dom(this).parentNode;
      Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
      //this._instances[idx] = inst;
      return inst;
    },

    // Implements extension point from Templatizer mixin
    _showHideChildren: function(hidden) {
      for (var i=0; i<this._instances.length; i++) {
        this._instances[i]._showHideChildren(hidden);
      }
    }
  });
</script>
