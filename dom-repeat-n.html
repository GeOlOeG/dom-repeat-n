<link rel="import" href="../polymer/polymer.html">

<!--
A template element that repeat `n` times its content.

Example:

    <template is"dom-repeat-n" count="3">
      <div>I am div {{index}}</div>
    </template>

@demo demo/index.html
@hero hero.svg
-->
<script>
  Polymer({
    is: 'dom-repeat-n',
    extends: 'template',
    // The following specifies that the element stamp directly no content,
    // i.e. does not have a <template> section declared
    _template: null,

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */

    properties: {
      /**
       * `count` specifies the number of times to repeat the template content.
       */
      count: {
        type: Number,
        value: 0,
        observer: '_countChanged'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the inst.  If `order` is provided, the index will reflect the
       * sorted order (rather than the original array order).
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * A string indicating the ordering 'ascending' or 'descending'.
       */
      order: {
        type: String,
        value: 'ascending',
        observer: '_orderChanged'
      }

    },

    behaviors: [
      Polymer.Templatizer
    ],

    // Element Lifecycle

    created: function() {
      this._instances = [];
      this._pool = [];
    },

    ready: function() {
      // Template instance props that should be excluded from forwarding
      this._instanceProps = {};
      this._instanceProps[this.indexAs] = true;
      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.ctor) {
        this.templatize(this);
      }
      console.log("ready!");
    },

    attached: function() {
      var parent = Polymer.dom(Polymer.dom(this).parentNode);
      for (var i=0; i<this._instances.length; i++) {
        this._attachInstance(i, parent);
      }
    },

    detached: function() {
      for (var i=0; i<this._instances.length; i++) {
        this._detachInstance(i);
      }
    },

    // Element Behavior

    _countChanged: function(newCount, oldCount) {
      oldCount = oldCount || 0;
      console.log("_countChanged: " + oldCount + " -> " + newCount);
      this._debounceTemplate(this._render);
    },

    _orderChanged: function(order, oldOrder) {
      console.log('_orderChanged');
      switch(order) {
        case 'ascending':
          console.log('Ascending');
          this._order = 1;
          break;
        case 'descending':
          console.log('Descending');
          this._order = -1;
          break;
        default:
          console.warn('Invalid order value (' + order + ') for dom-repeat-n.');
          this._order = 1;
      }
      this._debounceTemplate(this._render);
    },

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */
    render: function() {
      // Queue this repeater, then flush all in order
      this._debounceTemplate(this._render);
      this._flushTemplates();
    },

    _render: function() {
      console.log("_render");
      var i;
      // Generate missing instances if count increased
      for (i=0; i<this.count; i++) {
        var inst = this._instances[i];
        if (!inst) {
          inst = this._insertInstance(i);
        }
        if (this._order > 0) {
          inst.__setProperty(this.indexAs, i, true);
        } else {
          inst.__setProperty(this.indexAs, this.count-i-1, true);
        }
      }
      // Remove any extra instances from previous state
      for (i=this.count; i<this._instances.length; i++) {
        this._detachAndRemoveInstance(i);
      }
      // Notify users
      this.fire('dom-change');
    },

    _attachInstance: function(idx, parent) {
      var inst = this._instances[idx];
      if (!inst.isPlaceholder) {
        parent.insertBefore(inst.root, this);
      }
    },

    _detachInstance: function(idx) {
      var inst = this._instances[idx];
      if (!inst.isPlaceholder) {
        for (var i=0; i<inst._children.length; i++) {
          var el = inst._children[i];
          Polymer.dom(inst.root).appendChild(el);
        }
        return inst;
      }
    },

    _detachAndRemoveInstance: function(idx) {
      var inst = this._detachInstance(idx);
      if (inst) {
        this._pool.push(inst);
      }
      this._instances.splice(idx, 1);
    },

    _insertPlaceholder: function(idx) {
      this._instances.splice(idx, 0, {
        isPlaceholder: true
      });
    },

    _stampInstance: function(idx) {
      console.log("_stampInstance: " + idx);
      var model = {};
      model[this.indexAs] = idx;
      return this.stamp(model);
    },

    _insertInstance: function(idx) {
      console.log("_insertInstance: " + idx);
      var inst = this._pool.pop();
      if (!inst) {
        inst = this._stampInstance(idx);
        this._instances.push(inst);
      }
      var beforeRow = this._instances[idx + 1];
      var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
      var parentNode = Polymer.dom(this).parentNode;
      Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
      this._instances[idx] = inst;
      return inst;
    },

    // Implements extension point from Templatizer mixin
    _showHideChildren: function(hidden) {
      for (var i=0; i<this._instances.length; i++) {
        this._instances[i]._showHideChildren(hidden);
      }
    },

    // Called as a side effect of a template item change, responsible
    // for notifying items.<key-for-inst> change up to host
    _forwardInstanceProp: function(inst, prop, value) {
      // TODO PG: should be removed? Nothing to do...
    },

    // Implements extension point from Templatizer
    // Called as a side effect of a template instance path change, responsible
    // for notifying items.<key-for-inst>.<path> change up to host
    _forwardInstancePath: function(inst, path, value) {
      // TODO PG: should be removed? Nothing to do...
    },

    // Implements extension point from Templatizer mixin
    // Called as side-effect of a host property change, responsible for
    // notifying parent path change on each inst
    _forwardParentProp: function(prop, value) {
      var i$ = this._instances;
      for (var i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
        if (!inst.isPlaceholder) {
          inst.__setProperty(prop, value, true);
        }
      }
    },

    // Implements extension point from Templatizer
    // Called as side-effect of a host path change, responsible for
    // notifying parent path change on each inst
    _forwardParentPath: function(path, value) {
      var i$ = this._instances;
      for (var i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
        if (!inst.isPlaceholder) {
          inst._notifyPath(path, value, true);
        }
      }
    },
  });
</script>
